import {
  require_head,
  require_image_config,
  require_image_config_context_shared_runtime,
  require_match_local_pattern,
  require_match_remote_pattern,
  require_warn_once
} from "./chunk-MD5XCQV3.js";
import {
  require_normalize_trailing_slash,
  require_request_idle_callback
} from "./chunk-QCRZ6PU6.js";
import {
  require_interop_require_default,
  require_interop_require_wildcard
} from "./chunk-JZGNEPMT.js";
import {
  require_react_dom
} from "./chunk-S2TXWNJ2.js";
import {
  require_jsx_runtime
} from "./chunk-RER4HUWC.js";
import {
  require_react
} from "./chunk-I2HX37IS.js";
import {
  __commonJS
} from "./chunk-MVEJMUOB.js";

// node_modules/next/dist/client/use-intersection.js
var require_use_intersection = __commonJS({
  "node_modules/next/dist/client/use-intersection.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "useIntersection", {
      enumerable: true,
      get: function() {
        return useIntersection;
      }
    });
    var _react = require_react();
    var _requestidlecallback = require_request_idle_callback();
    var hasIntersectionObserver = typeof IntersectionObserver === "function";
    var observers = /* @__PURE__ */ new Map();
    var idList = [];
    function createObserver(options) {
      const id = {
        root: options.root || null,
        margin: options.rootMargin || ""
      };
      const existing = idList.find((obj) => obj.root === id.root && obj.margin === id.margin);
      let instance;
      if (existing) {
        instance = observers.get(existing);
        if (instance) {
          return instance;
        }
      }
      const elements = /* @__PURE__ */ new Map();
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          const callback = elements.get(entry.target);
          const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;
          if (callback && isVisible) {
            callback(isVisible);
          }
        });
      }, options);
      instance = {
        id,
        observer,
        elements
      };
      idList.push(id);
      observers.set(id, instance);
      return instance;
    }
    function observe(element, callback, options) {
      const { id, observer, elements } = createObserver(options);
      elements.set(element, callback);
      observer.observe(element);
      return function unobserve() {
        elements.delete(element);
        observer.unobserve(element);
        if (elements.size === 0) {
          observer.disconnect();
          observers.delete(id);
          const index = idList.findIndex((obj) => obj.root === id.root && obj.margin === id.margin);
          if (index > -1) {
            idList.splice(index, 1);
          }
        }
      };
    }
    function useIntersection(param) {
      let { rootRef, rootMargin, disabled } = param;
      const isDisabled = disabled || !hasIntersectionObserver;
      const [visible, setVisible] = (0, _react.useState)(false);
      const elementRef = (0, _react.useRef)(null);
      const setElement = (0, _react.useCallback)((element) => {
        elementRef.current = element;
      }, []);
      (0, _react.useEffect)(() => {
        if (hasIntersectionObserver) {
          if (isDisabled || visible) return;
          const element = elementRef.current;
          if (element && element.tagName) {
            const unobserve = observe(element, (isVisible) => isVisible && setVisible(isVisible), {
              root: rootRef == null ? void 0 : rootRef.current,
              rootMargin
            });
            return unobserve;
          }
        } else {
          if (!visible) {
            const idleCallback = (0, _requestidlecallback.requestIdleCallback)(() => setVisible(true));
            return () => (0, _requestidlecallback.cancelIdleCallback)(idleCallback);
          }
        }
      }, [
        isDisabled,
        rootMargin,
        rootRef,
        visible,
        elementRef.current
      ]);
      const resetVisible = (0, _react.useCallback)(() => {
        setVisible(false);
      }, []);
      return [
        setElement,
        visible,
        resetVisible
      ];
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// node_modules/next/dist/client/legacy/image.js
var require_image = __commonJS({
  "node_modules/next/dist/client/legacy/image.js"(exports, module) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return Image;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _interop_require_wildcard = require_interop_require_wildcard();
    var _jsxruntime = require_jsx_runtime();
    var _react = _interop_require_wildcard._(require_react());
    var _reactdom = _interop_require_wildcard._(require_react_dom());
    var _head = _interop_require_default._(require_head());
    var _imageconfig = require_image_config();
    var _useintersection = require_use_intersection();
    var _imageconfigcontextsharedruntime = require_image_config_context_shared_runtime();
    var _warnonce = require_warn_once();
    var _normalizetrailingslash = require_normalize_trailing_slash();
    function normalizeSrc(src) {
      return src[0] === "/" ? src.slice(1) : src;
    }
    var supportsFloat = typeof _reactdom.preload === "function";
    var DEFAULT_Q = 75;
    var configEnv = process.env.__NEXT_IMAGE_OPTS;
    var loadedImageURLs = /* @__PURE__ */ new Set();
    var allImgs = /* @__PURE__ */ new Map();
    var perfObserver;
    var emptyDataURL = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    if (typeof window === "undefined") {
      ;
      globalThis.__NEXT_IMAGE_IMPORTED = true;
    }
    var VALID_LOADING_VALUES = [
      "lazy",
      "eager",
      void 0
    ];
    function imgixLoader(param) {
      let { config, src, width, quality } = param;
      const url = new URL("" + config.path + normalizeSrc(src));
      const params = url.searchParams;
      params.set("auto", params.getAll("auto").join(",") || "format");
      params.set("fit", params.get("fit") || "max");
      params.set("w", params.get("w") || width.toString());
      if (quality) {
        params.set("q", quality.toString());
      }
      return url.href;
    }
    function akamaiLoader(param) {
      let { config, src, width } = param;
      return "" + config.path + normalizeSrc(src) + "?imwidth=" + width;
    }
    function cloudinaryLoader(param) {
      let { config, src, width, quality } = param;
      const params = [
        "f_auto",
        "c_limit",
        "w_" + width,
        "q_" + (quality || "auto")
      ];
      const paramsString = params.join(",") + "/";
      return "" + config.path + paramsString + normalizeSrc(src);
    }
    function customLoader(param) {
      let { src } = param;
      throw Object.defineProperty(new Error('Image with src "' + src + '" is missing "loader" prop.\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader'), "__NEXT_ERROR_CODE", {
        value: "E252",
        enumerable: false,
        configurable: true
      });
    }
    function defaultLoader(param) {
      let { config, src, width, quality } = param;
      var _config_qualities;
      if (true) {
        const missingValues = [];
        if (!src) missingValues.push("src");
        if (!width) missingValues.push("width");
        if (missingValues.length > 0) {
          throw Object.defineProperty(new Error("Next Image Optimization requires " + missingValues.join(", ") + " to be provided. Make sure you pass them as props to the `next/image` component. Received: " + JSON.stringify({
            src,
            width,
            quality
          })), "__NEXT_ERROR_CODE", {
            value: "E188",
            enumerable: false,
            configurable: true
          });
        }
        if (src.startsWith("//")) {
          throw Object.defineProperty(new Error('Failed to parse src "' + src + '" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'), "__NEXT_ERROR_CODE", {
            value: "E360",
            enumerable: false,
            configurable: true
          });
        }
        if (src.startsWith("/") && config.localPatterns) {
          if (
            // micromatch isn't compatible with edge runtime
            process.env.NEXT_RUNTIME !== "edge"
          ) {
            const { hasLocalMatch } = require_match_local_pattern();
            if (!hasLocalMatch(config.localPatterns, src)) {
              throw Object.defineProperty(new Error("Invalid src prop (" + src + ") on `next/image` does not match `images.localPatterns` configured in your `next.config.js`\nSee more info: https://nextjs.org/docs/messages/next-image-unconfigured-localpatterns"), "__NEXT_ERROR_CODE", {
                value: "E426",
                enumerable: false,
                configurable: true
              });
            }
          }
        }
        if (!src.startsWith("/") && (config.domains || config.remotePatterns)) {
          let parsedSrc;
          try {
            parsedSrc = new URL(src);
          } catch (err) {
            console.error(err);
            throw Object.defineProperty(new Error('Failed to parse src "' + src + '" on `next/image`, if using relative image it must start with a leading slash "/" or be an absolute URL (http:// or https://)'), "__NEXT_ERROR_CODE", {
              value: "E63",
              enumerable: false,
              configurable: true
            });
          }
          if (
            // micromatch isn't compatible with edge runtime
            process.env.NEXT_RUNTIME !== "edge"
          ) {
            const { hasRemoteMatch } = require_match_remote_pattern();
            if (!hasRemoteMatch(config.domains, config.remotePatterns, parsedSrc)) {
              throw Object.defineProperty(new Error("Invalid src prop (" + src + ') on `next/image`, hostname "' + parsedSrc.hostname + '" is not configured under images in your `next.config.js`\nSee more info: https://nextjs.org/docs/messages/next-image-unconfigured-host'), "__NEXT_ERROR_CODE", {
                value: "E231",
                enumerable: false,
                configurable: true
              });
            }
          }
        }
        if (quality && config.qualities && !config.qualities.includes(quality)) {
          throw Object.defineProperty(new Error("Invalid quality prop (" + quality + ") on `next/image` does not match `images.qualities` configured in your `next.config.js`\nSee more info: https://nextjs.org/docs/messages/next-image-unconfigured-qualities"), "__NEXT_ERROR_CODE", {
            value: "E623",
            enumerable: false,
            configurable: true
          });
        }
      }
      const q = quality || ((_config_qualities = config.qualities) == null ? void 0 : _config_qualities.reduce((prev, cur) => Math.abs(cur - DEFAULT_Q) < Math.abs(prev - DEFAULT_Q) ? cur : prev)) || DEFAULT_Q;
      if (!config.dangerouslyAllowSVG && src.split("?", 1)[0].endsWith(".svg")) {
        return src;
      }
      return (0, _normalizetrailingslash.normalizePathTrailingSlash)(config.path) + "?url=" + encodeURIComponent(src) + "&w=" + width + "&q=" + q;
    }
    var loaders = /* @__PURE__ */ new Map([
      [
        "default",
        defaultLoader
      ],
      [
        "imgix",
        imgixLoader
      ],
      [
        "cloudinary",
        cloudinaryLoader
      ],
      [
        "akamai",
        akamaiLoader
      ],
      [
        "custom",
        customLoader
      ]
    ]);
    var VALID_LAYOUT_VALUES = [
      "fill",
      "fixed",
      "intrinsic",
      "responsive",
      void 0
    ];
    function isStaticRequire(src) {
      return src.default !== void 0;
    }
    function isStaticImageData(src) {
      return src.src !== void 0;
    }
    function isStaticImport(src) {
      return typeof src === "object" && (isStaticRequire(src) || isStaticImageData(src));
    }
    function getWidths(param, width, layout, sizes) {
      let { deviceSizes, allSizes } = param;
      if (sizes && (layout === "fill" || layout === "responsive")) {
        const viewportWidthRe = /(^|\s)(1?\d?\d)vw/g;
        const percentSizes = [];
        for (let match; match = viewportWidthRe.exec(sizes); match) {
          percentSizes.push(parseInt(match[2]));
        }
        if (percentSizes.length) {
          const smallestRatio = Math.min(...percentSizes) * 0.01;
          return {
            widths: allSizes.filter((s) => s >= deviceSizes[0] * smallestRatio),
            kind: "w"
          };
        }
        return {
          widths: allSizes,
          kind: "w"
        };
      }
      if (typeof width !== "number" || layout === "fill" || layout === "responsive") {
        return {
          widths: deviceSizes,
          kind: "w"
        };
      }
      const widths = [
        ...new Set(
          // > This means that most OLED screens that say they are 3x resolution,
          // > are actually 3x in the green color, but only 1.5x in the red and
          // > blue colors. Showing a 3x resolution image in the app vs a 2x
          // > resolution image will be visually the same, though the 3x image
          // > takes significantly more data. Even true 3x resolution screens are
          // > wasteful as the human eye cannot see that level of detail without
          // > something like a magnifying glass.
          // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html
          [
            width,
            width * 2
            /*, width * 3*/
          ].map((w) => allSizes.find((p) => p >= w) || allSizes[allSizes.length - 1])
        )
      ];
      return {
        widths,
        kind: "x"
      };
    }
    function generateImgAttrs(param) {
      let { config, src, unoptimized, layout, width, quality, sizes, loader } = param;
      if (unoptimized) {
        return {
          src,
          srcSet: void 0,
          sizes: void 0
        };
      }
      const { widths, kind } = getWidths(config, width, layout, sizes);
      const last = widths.length - 1;
      return {
        sizes: !sizes && kind === "w" ? "100vw" : sizes,
        srcSet: widths.map((w, i) => loader({
          config,
          src,
          quality,
          width: w
        }) + " " + (kind === "w" ? w : i + 1) + kind).join(", "),
        // It's intended to keep `src` the last attribute because React updates
        // attributes in order. If we keep `src` the first one, Safari will
        // immediately start to fetch `src`, before `sizes` and `srcSet` are even
        // updated by React. That causes multiple unnecessary requests if `srcSet`
        // and `sizes` are defined.
        // This bug cannot be reproduced in Chrome or Firefox.
        src: loader({
          config,
          src,
          quality,
          width: widths[last]
        })
      };
    }
    function getInt(x) {
      if (typeof x === "number") {
        return x;
      }
      if (typeof x === "string") {
        return parseInt(x, 10);
      }
      return void 0;
    }
    function defaultImageLoader(loaderProps) {
      var _loaderProps_config;
      const loaderKey = ((_loaderProps_config = loaderProps.config) == null ? void 0 : _loaderProps_config.loader) || "default";
      const load = loaders.get(loaderKey);
      if (load) {
        return load(loaderProps);
      }
      throw Object.defineProperty(new Error('Unknown "loader" found in "next.config.js". Expected: ' + _imageconfig.VALID_LOADERS.join(", ") + ". Received: " + loaderKey), "__NEXT_ERROR_CODE", {
        value: "E338",
        enumerable: false,
        configurable: true
      });
    }
    function handleLoading(img, src, layout, placeholder, onLoadingCompleteRef, setBlurComplete) {
      if (!img || img.src === emptyDataURL || img["data-loaded-src"] === src) {
        return;
      }
      img["data-loaded-src"] = src;
      const p = "decode" in img ? img.decode() : Promise.resolve();
      p.catch(() => {
      }).then(() => {
        if (!img.parentNode) {
          return;
        }
        loadedImageURLs.add(src);
        if (placeholder === "blur") {
          setBlurComplete(true);
        }
        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {
          const { naturalWidth, naturalHeight } = img;
          onLoadingCompleteRef.current({
            naturalWidth,
            naturalHeight
          });
        }
        if (true) {
          var _img_parentElement;
          if ((_img_parentElement = img.parentElement) == null ? void 0 : _img_parentElement.parentElement) {
            const parent = getComputedStyle(img.parentElement.parentElement);
            if (!parent.position) {
            } else if (layout === "responsive" && parent.display === "flex") {
              (0, _warnonce.warnOnce)('Image with src "' + src + '" may not render properly as a child of a flex container. Consider wrapping the image with a div to configure the width.');
            } else if (layout === "fill" && parent.position !== "relative" && parent.position !== "fixed" && parent.position !== "absolute") {
              (0, _warnonce.warnOnce)('Image with src "' + src + '" may not render properly with a parent using position:"' + parent.position + '". Consider changing the parent style to position:"relative" with a width and height.');
            }
          }
        }
      });
    }
    var ImageElement = (param) => {
      let { imgAttributes, heightInt, widthInt, qualityInt, layout, className, imgStyle, blurStyle, isLazy, placeholder, loading, srcString, config, unoptimized, loader, onLoadingCompleteRef, setBlurComplete, setIntersection, onLoad, onError, isVisible, noscriptSizes, ...rest } = param;
      loading = isLazy ? "lazy" : loading;
      return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
          (0, _jsxruntime.jsx)("img", {
            ...rest,
            ...imgAttributes,
            decoding: "async",
            "data-nimg": layout,
            className,
            style: {
              ...imgStyle,
              ...blurStyle
            },
            ref: (0, _react.useCallback)((img) => {
              if (true) {
                if (img && !srcString) {
                  console.error('Image is missing required "src" property:', img);
                }
              }
              setIntersection(img);
              if (img == null ? void 0 : img.complete) {
                handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);
              }
            }, [
              setIntersection,
              srcString,
              layout,
              placeholder,
              onLoadingCompleteRef,
              setBlurComplete
            ]),
            onLoad: (event) => {
              const img = event.currentTarget;
              handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);
              if (onLoad) {
                onLoad(event);
              }
            },
            onError: (event) => {
              if (placeholder === "blur") {
                setBlurComplete(true);
              }
              if (onError) {
                onError(event);
              }
            }
          }),
          (isLazy || placeholder === "blur") && (0, _jsxruntime.jsx)("noscript", {
            children: (0, _jsxruntime.jsx)("img", {
              ...rest,
              // @ts-ignore - TODO: upgrade to `@types/react@17`
              loading,
              decoding: "async",
              "data-nimg": layout,
              style: imgStyle,
              className,
              ...generateImgAttrs({
                config,
                src: srcString,
                unoptimized,
                layout,
                width: widthInt,
                quality: qualityInt,
                sizes: noscriptSizes,
                loader
              })
            })
          })
        ]
      });
    };
    function Image(param) {
      let { src, sizes, unoptimized = false, priority = false, loading, lazyRoot = null, lazyBoundary, className, quality, width, height, style, objectFit, objectPosition, onLoadingComplete, placeholder = "empty", blurDataURL, ...all } = param;
      const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);
      const config = (0, _react.useMemo)(() => {
        var _c_qualities;
        const c = configEnv || configContext || _imageconfig.imageConfigDefault;
        const allSizes = [
          ...c.deviceSizes,
          ...c.imageSizes
        ].sort((a, b) => a - b);
        const deviceSizes = c.deviceSizes.sort((a, b) => a - b);
        const qualities = (_c_qualities = c.qualities) == null ? void 0 : _c_qualities.sort((a, b) => a - b);
        return {
          ...c,
          allSizes,
          deviceSizes,
          qualities
        };
      }, [
        configContext
      ]);
      let rest = all;
      let layout = sizes ? "responsive" : "intrinsic";
      if ("layout" in rest) {
        if (rest.layout) layout = rest.layout;
        delete rest.layout;
      }
      let loader = defaultImageLoader;
      if ("loader" in rest) {
        if (rest.loader) {
          const customImageLoader = rest.loader;
          loader = (obj) => {
            const { config: _, ...opts } = obj;
            return customImageLoader(opts);
          };
        }
        delete rest.loader;
      }
      let staticSrc = "";
      if (isStaticImport(src)) {
        const staticImageData = isStaticRequire(src) ? src.default : src;
        if (!staticImageData.src) {
          throw Object.defineProperty(new Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received " + JSON.stringify(staticImageData)), "__NEXT_ERROR_CODE", {
            value: "E460",
            enumerable: false,
            configurable: true
          });
        }
        blurDataURL = blurDataURL || staticImageData.blurDataURL;
        staticSrc = staticImageData.src;
        if (!layout || layout !== "fill") {
          height = height || staticImageData.height;
          width = width || staticImageData.width;
          if (!staticImageData.height || !staticImageData.width) {
            throw Object.defineProperty(new Error("An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received " + JSON.stringify(staticImageData)), "__NEXT_ERROR_CODE", {
              value: "E48",
              enumerable: false,
              configurable: true
            });
          }
        }
      }
      src = typeof src === "string" ? src : staticSrc;
      let isLazy = !priority && (loading === "lazy" || typeof loading === "undefined");
      if (src.startsWith("data:") || src.startsWith("blob:")) {
        unoptimized = true;
        isLazy = false;
      }
      if (typeof window !== "undefined" && loadedImageURLs.has(src)) {
        isLazy = false;
      }
      if (config.unoptimized) {
        unoptimized = true;
      }
      const [blurComplete, setBlurComplete] = (0, _react.useState)(false);
      const [setIntersection, isIntersected, resetIntersected] = (0, _useintersection.useIntersection)({
        rootRef: lazyRoot,
        rootMargin: lazyBoundary || "200px",
        disabled: !isLazy
      });
      const isVisible = !isLazy || isIntersected;
      const wrapperStyle = {
        boxSizing: "border-box",
        display: "block",
        overflow: "hidden",
        width: "initial",
        height: "initial",
        background: "none",
        opacity: 1,
        border: 0,
        margin: 0,
        padding: 0
      };
      const sizerStyle = {
        boxSizing: "border-box",
        display: "block",
        width: "initial",
        height: "initial",
        background: "none",
        opacity: 1,
        border: 0,
        margin: 0,
        padding: 0
      };
      let hasSizer = false;
      let sizerSvgUrl;
      const layoutStyle = {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        boxSizing: "border-box",
        padding: 0,
        border: "none",
        margin: "auto",
        display: "block",
        width: 0,
        height: 0,
        minWidth: "100%",
        maxWidth: "100%",
        minHeight: "100%",
        maxHeight: "100%",
        objectFit,
        objectPosition
      };
      let widthInt = getInt(width);
      let heightInt = getInt(height);
      const qualityInt = getInt(quality);
      if (true) {
        if (!src) {
          widthInt = widthInt || 1;
          heightInt = heightInt || 1;
          unoptimized = true;
        } else {
          if (!VALID_LAYOUT_VALUES.includes(layout)) {
            throw Object.defineProperty(new Error('Image with src "' + src + '" has invalid "layout" property. Provided "' + layout + '" should be one of ' + VALID_LAYOUT_VALUES.map(String).join(",") + "."), "__NEXT_ERROR_CODE", {
              value: "E420",
              enumerable: false,
              configurable: true
            });
          }
          if (typeof widthInt !== "undefined" && isNaN(widthInt) || typeof heightInt !== "undefined" && isNaN(heightInt)) {
            throw Object.defineProperty(new Error('Image with src "' + src + '" has invalid "width" or "height" property. These should be numeric values.'), "__NEXT_ERROR_CODE", {
              value: "E99",
              enumerable: false,
              configurable: true
            });
          }
          if (layout === "fill" && (width || height)) {
            (0, _warnonce.warnOnce)('Image with src "' + src + `" and "layout='fill'" has unused properties assigned. Please remove "width" and "height".`);
          }
          if (!VALID_LOADING_VALUES.includes(loading)) {
            throw Object.defineProperty(new Error('Image with src "' + src + '" has invalid "loading" property. Provided "' + loading + '" should be one of ' + VALID_LOADING_VALUES.map(String).join(",") + "."), "__NEXT_ERROR_CODE", {
              value: "E357",
              enumerable: false,
              configurable: true
            });
          }
          if (priority && loading === "lazy") {
            throw Object.defineProperty(new Error('Image with src "' + src + `" has both "priority" and "loading='lazy'" properties. Only one should be used.`), "__NEXT_ERROR_CODE", {
              value: "E218",
              enumerable: false,
              configurable: true
            });
          }
          if (sizes && layout !== "fill" && layout !== "responsive") {
            (0, _warnonce.warnOnce)('Image with src "' + src + `" has "sizes" property but it will be ignored. Only use "sizes" with "layout='fill'" or "layout='responsive'"`);
          }
          if (placeholder === "blur") {
            if (layout !== "fill" && (widthInt || 0) * (heightInt || 0) < 1600) {
              (0, _warnonce.warnOnce)('Image with src "' + src + `" is smaller than 40x40. Consider removing the "placeholder='blur'" property to improve performance.`);
            }
            if (!blurDataURL) {
              const VALID_BLUR_EXT = [
                "jpeg",
                "png",
                "webp",
                "avif"
              ];
              throw Object.defineProperty(new Error('Image with src "' + src + `" has "placeholder='blur'" property but is missing the "blurDataURL" property.
          Possible solutions:
            - Add a "blurDataURL" property, the contents should be a small Data URL to represent the image
            - Change the "src" property to a static import with one of the supported file types: ` + VALID_BLUR_EXT.join(",") + ' (animated images not supported)\n            - Remove the "placeholder" property, effectively no blur effect\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'), "__NEXT_ERROR_CODE", {
                value: "E89",
                enumerable: false,
                configurable: true
              });
            }
          }
          if ("ref" in rest) {
            (0, _warnonce.warnOnce)('Image with src "' + src + '" is using unsupported "ref" property. Consider using the "onLoadingComplete" property instead.');
          }
          if (!unoptimized && loader !== defaultImageLoader) {
            const urlStr = loader({
              config,
              src,
              width: widthInt || 400,
              quality: qualityInt || 75
            });
            let url;
            try {
              url = new URL(urlStr);
            } catch (err) {
            }
            if (urlStr === src || url && url.pathname === src && !url.search) {
              (0, _warnonce.warnOnce)('Image with src "' + src + '" has a "loader" property that does not implement width. Please implement it or use the "unoptimized" property instead.\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width');
            }
          }
          if (style) {
            let overwrittenStyles = Object.keys(style).filter((key) => key in layoutStyle);
            if (overwrittenStyles.length) {
              (0, _warnonce.warnOnce)("Image with src " + src + " is assigned the following styles, which are overwritten by automatically-generated styles: " + overwrittenStyles.join(", "));
            }
          }
          if (typeof window !== "undefined" && !perfObserver && window.PerformanceObserver) {
            perfObserver = new PerformanceObserver((entryList) => {
              for (const entry of entryList.getEntries()) {
                var _entry_element;
                const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || "";
                const lcpImage = allImgs.get(imgSrc);
                if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== "blur" && !lcpImage.src.startsWith("data:") && !lcpImage.src.startsWith("blob:")) {
                  (0, _warnonce.warnOnce)('Image with src "' + lcpImage.src + '" was detected as the Largest Contentful Paint (LCP). Please add the "priority" property if this image is above the fold.\nRead more: https://nextjs.org/docs/api-reference/next/legacy/image#priority');
                }
              }
            });
            try {
              perfObserver.observe({
                type: "largest-contentful-paint",
                buffered: true
              });
            } catch (err) {
              console.error(err);
            }
          }
        }
      }
      const imgStyle = Object.assign({}, style, layoutStyle);
      const blurStyle = placeholder === "blur" && !blurComplete ? {
        backgroundSize: objectFit || "cover",
        backgroundPosition: objectPosition || "0% 0%",
        filter: "blur(20px)",
        backgroundImage: 'url("' + blurDataURL + '")'
      } : {};
      if (layout === "fill") {
        wrapperStyle.display = "block";
        wrapperStyle.position = "absolute";
        wrapperStyle.top = 0;
        wrapperStyle.left = 0;
        wrapperStyle.bottom = 0;
        wrapperStyle.right = 0;
      } else if (typeof widthInt !== "undefined" && typeof heightInt !== "undefined") {
        const quotient = heightInt / widthInt;
        const paddingTop = isNaN(quotient) ? "100%" : "" + quotient * 100 + "%";
        if (layout === "responsive") {
          wrapperStyle.display = "block";
          wrapperStyle.position = "relative";
          hasSizer = true;
          sizerStyle.paddingTop = paddingTop;
        } else if (layout === "intrinsic") {
          wrapperStyle.display = "inline-block";
          wrapperStyle.position = "relative";
          wrapperStyle.maxWidth = "100%";
          hasSizer = true;
          sizerStyle.maxWidth = "100%";
          sizerSvgUrl = "data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27" + widthInt + "%27%20height=%27" + heightInt + "%27/%3e";
        } else if (layout === "fixed") {
          wrapperStyle.display = "inline-block";
          wrapperStyle.position = "relative";
          wrapperStyle.width = widthInt;
          wrapperStyle.height = heightInt;
        }
      } else {
        if (true) {
          throw Object.defineProperty(new Error('Image with src "' + src + `" must use "width" and "height" properties or "layout='fill'" property.`), "__NEXT_ERROR_CODE", {
            value: "E495",
            enumerable: false,
            configurable: true
          });
        }
      }
      let imgAttributes = {
        src: emptyDataURL,
        srcSet: void 0,
        sizes: void 0
      };
      if (isVisible) {
        imgAttributes = generateImgAttrs({
          config,
          src,
          unoptimized,
          layout,
          width: widthInt,
          quality: qualityInt,
          sizes,
          loader
        });
      }
      let srcString = src;
      if (true) {
        if (typeof window !== "undefined") {
          let fullUrl;
          try {
            fullUrl = new URL(imgAttributes.src);
          } catch (e) {
            fullUrl = new URL(imgAttributes.src, window.location.href);
          }
          allImgs.set(fullUrl.href, {
            src,
            priority,
            placeholder
          });
        }
      }
      const linkProps = supportsFloat ? void 0 : {
        imageSrcSet: imgAttributes.srcSet,
        imageSizes: imgAttributes.sizes,
        crossOrigin: rest.crossOrigin,
        referrerPolicy: rest.referrerPolicy
      };
      const useLayoutEffect = typeof window === "undefined" ? _react.default.useEffect : _react.default.useLayoutEffect;
      const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);
      const previousImageSrc = (0, _react.useRef)(src);
      (0, _react.useEffect)(() => {
        onLoadingCompleteRef.current = onLoadingComplete;
      }, [
        onLoadingComplete
      ]);
      useLayoutEffect(() => {
        if (previousImageSrc.current !== src) {
          resetIntersected();
          previousImageSrc.current = src;
        }
      }, [
        resetIntersected,
        src
      ]);
      const imgElementArgs = {
        isLazy,
        imgAttributes,
        heightInt,
        widthInt,
        qualityInt,
        layout,
        className,
        imgStyle,
        blurStyle,
        loading,
        config,
        unoptimized,
        placeholder,
        loader,
        srcString,
        onLoadingCompleteRef,
        setBlurComplete,
        setIntersection,
        isVisible,
        noscriptSizes: sizes,
        ...rest
      };
      return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
          (0, _jsxruntime.jsxs)("span", {
            style: wrapperStyle,
            children: [
              hasSizer ? (0, _jsxruntime.jsx)("span", {
                style: sizerStyle,
                children: sizerSvgUrl ? (0, _jsxruntime.jsx)("img", {
                  style: {
                    display: "block",
                    maxWidth: "100%",
                    width: "initial",
                    height: "initial",
                    background: "none",
                    opacity: 1,
                    border: 0,
                    margin: 0,
                    padding: 0
                  },
                  alt: "",
                  "aria-hidden": true,
                  src: sizerSvgUrl
                }) : null
              }) : null,
              (0, _jsxruntime.jsx)(ImageElement, {
                ...imgElementArgs
              })
            ]
          }),
          !supportsFloat && priority ? (
            // Note how we omit the `href` attribute, as it would only be relevant
            // for browsers that do not support `imagesrcset`, and in those cases
            // it would likely cause the incorrect image to be preloaded.
            //
            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset
            (0, _jsxruntime.jsx)(_head.default, {
              children: (0, _jsxruntime.jsx)("link", {
                rel: "preload",
                as: "image",
                href: imgAttributes.srcSet ? void 0 : imgAttributes.src,
                ...linkProps
              }, "__nimg-" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)
            })
          ) : null
        ]
      });
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// node_modules/next/legacy/image.js
var require_image2 = __commonJS({
  "node_modules/next/legacy/image.js"(exports, module) {
    module.exports = require_image();
  }
});
export default require_image2();
//# sourceMappingURL=next_legacy_image.js.map
